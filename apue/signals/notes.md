# SIGNALS

## Introduction

* signals are software interrupts, which provide a way to deal with asynchronous events, i.e.
  * a user typing the interrupt key
  * the next program in a pipeline terminating

## Signal concepts

* every signal has a name and starts with SIG
  * SIGABRT is the abort signal that is generated when the process calls the `abort` function
  * SIGALRM is the alarm signal that is generated when the timer set by the `alarm` function goes off
  * there are a lot of different signals (30+) which are defined in `<signal.h>`
* each signal is defined by a positive integer, no signal is associated to 0 (null signal)
* a signal may be caused by
  * terminal signals, like SIGINT
  * hardware exceptions, like division by 0, invalid memory reference (SIGSEGV)
  * the `kill` function allows a process to send any signal to another process or process group
  * the `kill` command allows us to send signals to other processes, just an interface
  * software conditions can generate signals when certain conditions happen, SIGPIPE (when a process writes to a pipe after the reader of the pipe has terminated)
* signals are classic examples of asynchronous events
* we can tell the kernel to do one of three things when a signal occurs:
  * ignore the signal. This works for most of the signals except for SIGKILL and SIGSTOP, since the kernel must maintain a way to kill processes
  * catch the signal. To do this, we must tell the kernel to call a function when a signal occurs:
    * we may want to do this to allow users to press Control-C in a shell
    * or to catch SIGCHLD and handle the termination of a child process
    * or to catch SIGTERM to clean all temporary files before terminating
  * let the defaults apply. Every signal has a default behaviour; generally it is to terminate the process
* some signals may cause the creation of a core file, which can be opened by a debugger to inspect the cause of the signal

### Most important signals

* `SIGABRT`: `abort` function, the process terminates abnormally
* `SIGALRM`: generated when a timer set with the `alarm` function expires (also `setitimer` causes this)
* `SIGCHLD`: when a process terminates or stops, this is sent to its parent; by default, this signal is ignored
  * usually inside the signal handler wait is called to fetch the child termination status
* `SIGCONT`: this signal is sent to a stopped process when it is continued; in this case, the default behaviour is to continue the process, if it was stopped
* `SIGFPE`: arithmetic exception
* `SIGHUP`: this signal is sent to the controlling process (session leader) when a disconnect is detected by the terminal interface (note that the controlling process may be in the background)
  * also this signal is sent to the foreground process group when the session leader terminates (i.e. reboot)
  * commonly used to tell daemons to re-read their configuration files (since daemons do not have controlling terminals and SIGHUP would be non-sense)
* `SIGINT`: signal generated by the terminal when we press Control-C and sent to all processes in the foreground process group
* `SIGKILL`: signal which can't be ignored, terminates a process
* `SIGPIPE`: this signal is generated when we write to a pipe but the read-end of the pipe has already been closed
* `SIGIO, SIGPOLL`: I/O related asynchronous events
* `SIGPWR`: generally sent by the kernel to hardware connected to batteries, when the charge is very low and system should shutdown
* `SIGQUIT`: this signal is generated by the terminal driver when we type the terminal quit key (Control-backslash)
  * this is sent to all processes in the foreground process group
  * by default, it terminates and generates a core file
* `SIGSEV`: memory violation
* `SIGSTOP`: this signal stops a process, it's very similar to SIGTSTP but it cannot be ignored
* `SIGSYS`: invalid system call, generally when we update some kernel API
* `SIGTERM`: default signal sent by `kill`
* `SIGTSTP`: signal sent by the terminal driver when we press Control-Z to push the foreground process group into background
* `SIGTTIN`: this signal is generated when a background process wants to read from the controlling terminal
* `SIGTTOU`: this signals that a background process is writing to the controlling terminal; this can be allowed normally
* `SIGUSR1, SIGUSR2`: user defined signals
* `SIGWINCH`: this signal is sent when the kernel detects a change of size of a terminal or pseudo-terminal

## signal function

* `void (*signal (int signo, void (*func) (int))) (int)`
* the signo argument is simply the name of the signal
* the value of func may be
  * the constant `SIG_IGN`, to ignore the signal
  * the constact `SIG_DFL`, to reset the default behaviour associated to the signal
  * the address of a function to be called when the signal occurs (signal handler or signal-catching function)
* the signature of the signal function could be made much more simpler with
  * `typedef void Sigfunc(int)`
  * `Sigfunc *signal(int signo, Sigfunc *func)`
* generally the constants are defined as
  * `#define SIG_ERR    (void (*) ()) -1`
  * `#define SIG_DFL    (void (*) ())  0`
  * `#define SIG_IGN    (void (*) ())  1`

### Program startup

* when a program is executed, the status of all signals is either default or ignore
* when an exec is performed, all caught signals are resetted to their default behaviour (functions addresses would be meaningless after the exec is done)
* if we would want to catch SIGINT only if it wasn't ignored

  ```c
  static void sig_int(int);

  if (signal(SIGINT, SIG_IGN) != SIG_IGN)
    signal(SIGINT, sig_int);
  ```
* as we can see, a limitation of the signal command is that it can't read the signal behaviour without changing it
* across a fork, since the child has an exact memory copy of the parent, signal handlers are inherited

## Unreliable signals

* originally the signal handling was very unreliable
* a signal could only be caught once, then the handler ought to be re-established
  * but this led problems with timing (classic 'works correctly 99.99% of the time' problems)

## Interrupted system calls

* system calls were divided in: "slow" system calls and all the others. The slow ones may involve
  * reads that can block the caller forever (pipes, terminals, network devices)
  * writes that can block the caller forever
  * `pause` function
  * some ioctl operations
  * some IPC functions
* disk I/O is not a slow system call since the disk driver queues the request and immediately unblocks the caller
* to prevent from manually restarting operations 4.2BSD made some system calls to be restarted automatically:
  * `ioctl, read, readv, write, writev, wait, waitpid`
    * the first five are interrupted by a signal only if they are operating on a slow device (i.e. a terminal)
    * the last two are always interrupted by a signal

## Reentrant functions

* when a process receives a signal which is being handled
  * the normal order of execution is interrupted and the handler code is executed
  * if the handler returns with exit or longjmp, the normal sequence of operations is resumed
* the problem is that in the handler function we don't know what the original function was doing
  * it could have been in the middle of a malloc
  * can the signal handler call malloc?
* some re-entrant functions
  * `abort, alarm, chdir, chmod, chown, creat, dup, execve, _exit, fork, getpid, getppid, kill, mkdir, open, sleep, stat, time, umask, wait, waitpid`
* not re-entrant functions
  * functions which use static data structures
  * functions which use malloc or free
  * most of standard I/O since it uses global data structures in a not re-entrant way
* even when using re-entrant functions, note that there is only one errno per thread:
  * the signal handler should save errno before calling those functions and restore them afterwards

## Reliable signal terminology

* life of a signal
  * a signal is _generated_ for a process when a certain event happens
  * a signal is _delivered_ to a process when the action for a signal is taken
    * in the period between the generation and the delivery, the signal is _pending_
  * a process can _block_ the delivery of a signal
    * the signal remains pending until the process unblocks it or decides to ignore it
    * each process has a signal mask which defines the set of signals currently blocked

## kill and raise functions

* `int kill(pid_t pid, int signo)` sends a signal to a process or a group of processes
* `int raise(int signo)` allows a process to send a signal to itself
* `raise(signo) == kill(getpid(), signo)`
* there are four different types of pid that can be used with kill:
  * pid > 0, signal is sent to process with PID pid
  * pid == 0, signal is sent to all processes where PGRP ID is equal to the sender PGRP ID
    * this happens only if the process has permissions to send signals to those processes (superuser or if real/effective user ID of sender is equal to the receiver's ones)
    * a group of processes (like init) are not affected by this
  * pid < 0, signal is sent to all processes with PGRP ID equal to pid
* if signo is 0, we have the `null signal`
  * normal error checking is performed, but no signal is sent
  * this can be used to see if a certain process exists
    * kill returns -1 if it can't find a process and sets errno to ESRCH
    * UNIX recycles IDs after some time, so it's not a sure way to find if a process exists
    * moreover, this test for existence is not atomic, so it is of limited value

## alarm and pause functions

* `unsigned int alarm(unsigned int seconds)` allows us to set a timer that will expire in `seconds` seconds generating SIGALRM
  * if we don't ignore or catch this signal, the default action is to terminate the process
* there can only be one alarm for process
  * if we call alarm and the previous timer is not expired yet, it sets a new timer and returns with the number of seconds left
  * if we call alarm with 0 seconds, the previous alarm is canceled, still returning the number of seconds left
* `int pause(void)` suspends the calling process until a signal is caught
* using alarm and pause we can build a simple version of the `sleep` program
  * in `sleep1.c` there are a few problems though
    * if a signal handler was set to catch SIGALRM, it is lost
    * if an alarm timer was already going on, it is lost
    * there is a race condition between the call to alarm and the call to pause; in busy systems we could wait forever for the signal
  * in `sleep2.c` a problem may arise if we interrupt the execution of another signal handler
    * the other signal handler is interrupted and will never terminate

## Signal sets

* to represent a signal mask:
  * since there are generally more signals than bits in an integer, we have to use another data type
  * POSIX defines `sigset_t` and 5 functions to manipulate this set
    * `int sigemptyset(sigset_t *set)`
    * `int sigfillset(sigset_t *set)`
    * `int sigaddset(sigset_t *set, int signo)`
    * `int sigdelset(sigset_t *set, int signo)`
    * `int sigismember(const sigset_t *set, int signo)`

## sigprocmask function

* `int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset)`
* how may be: `SIG_BLOCK, SIG_UNBLOCK and SIG_SETMASK`

## sigpending function

* `int sigpending(sigset_t *set)` returns the set of signals that are blocked from delivery
* in general additional occurences of the same signal are not queued

## sigaction function

* the sigaction function let us examine or modify the action associated to a particular signal
* this function supersedes the signal function
* `int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oact)`
  * signo is the signal we are considering
  * if act is not NULL, it is the action we're modifying
  * if oact is not NULL, it is where the previous action is saved
  * example of struct

    ```c
    struct sigaction {
      void (*sa_handler) (int); /* signal handler */
      sigset_t sa_mask;         /* signals to block */
      int      sa_flags;        /* signal options */

      /* alternate handler */
      void (*sa_sigaction) (int, siginfo_t *, void *)
    }
    ```
* once we install a signal handler, that action remains installed until we explicitly change it with sigaction

## sigsetjmp and siglongjmp functions

* these functions should be used when branching from a signal handler
  * they save the current signal mask and restore is accordingly

## sigsuspend function

* we can use sigprocmask blocking behaviour to protect critical regions of code from signal interrupts
  * unfortunately this implementation wouldn't be atomic, since:
    * after we reset the mask, a queued signal would be received before being able to call pause
* `int sigsuspend(const sigset_t *set)` resets the signal mask and puts the process to sleep in a single atomic operation
* it can be used also to wait for a signal handler to set a global variable
* the sigsuspend function is useful when we want to sleep while waiting for a signal to occur

## abort function

* `void abort(void)` sends SIGABRT to the caller
* processes which catch this signal shouldn't return to the caller
  * they must use some form of exit
  * this chance is given to the process to perform some cleanup
* we can find in `abort.c` an implementation as specified by POSIX

## system function

* POSIX requires that `system` ignores SIGINT and SIGQUIT and blocks SIGCHLD
  * SIGCHLD should be blocked because
    * when the child created by system terminates
    * the caller of system would think that one of its own children had terminated
    * and would wait for the value of the process
    * thus preventing system from returning its child termination status
  * SIGINT and SIGQUIT should be ignore because
    * the terminal sends these signals to all processes in the foreground group
    * they should therefore ignore those signals and let only the child receive them

## sleep function

* `unsigned int sleep(unsigned int seconds)` makes the calling process suspended until
  * the timer specified by seconds is elapsed, and it returns 0
  * a signal is caught by the process and the signal handler returns, and it returns the amount of seconds left
* we can see a POSIX compliant implementation in `sleep.c`

## Job-control signals

* there are many job-control signals
  * `SIGCHLD` child process has stopped or terminated
  * `SIGCONT` continue process, if stopped
  * `SIGSTOP` stop signal (can't be caught or ignored)
  * `SIGTSTP` interactive stop signal
  * `SIGTTIN` read from controlling terminal by a member of a background pr group
  * `SIGTTOU` write to controlling terminal by a member of a background pr group
* generally the job-control shell takes care of most of the handling
* except for SIGCHLD, usually programs don't interact with these signals
  * vi has to catch suspend and continue signals to save its internal data and restore it later
  * we can see an example in `sigtstp.c`

## Additional features

* signals are sometimes associated to numbers with a `extern char *syg_syslist[]` array
* `void psignal(int signo, const char *msg)` print the name of the signal, followed by a short description
  * similar to perror
* `char *strsignal(int signo)` returns the string that describes the signal
  * similar to strerror
