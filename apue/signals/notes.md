# SIGNALS

## Introduction

* signals are software interrupts, which provide a way to deal with asynchronous events, i.e.
  * a user typing the interrupt key
  * the next program in a pipeline terminating

## Signal concepts

* every signal has a name and starts with SIG
  * SIGABRT is the abort signal that is generated when the process calls the `abort` function
  * SIGALRM is the alarm signal that is generated when the timer set by the `alarm` function goes off
  * there are a lot of different signals (30+) which are defined in `<signal.h>`
* each signal is defined by a positive integer, no signal is associated to 0 (null signal)
* a signal may be caused by
  * terminal signals, like SIGINT
  * hardware exceptions, like division by 0, invalid memory reference (SIGSEGV)
  * the `kill` function allows a process to send any signal to another process or process group
  * the `kill` command allows us to send signals to other processes, just an interface
  * software conditions can generate signals when certain conditions happen, SIGPIPE (when a process writes to a pipe after the reader of the pipe has terminated)
* signals are classic examples of asynchronous events
* we can tell the kernel to do one of three things when a signal occurs:
  * ignore the signal. This works for most of the signals except for SIGKILL and SIGSTOP, since the kernel must maintain a way to kill processes
  * catch the signal. To do this, we must tell the kernel to call a function when a signal occurs:
    * we may want to do this to allow users to press Control-C in a shell
    * or to catch SIGCHLD and handle the termination of a child process
    * or to catch SIGTERM to clean all temporary files before terminating
  * let the defaults apply. Every signal has a default behaviour; generally it is to terminate the process
* some signals may cause the creation of a core file, which can be opened by a debugger to inspect the cause of the signal

### Most important signals

* `SIGABRT`: `abort` function, the process terminates abnormally
* `SIGALRM`: generated when a timer set with the `alarm` function expires (also `setitimer` causes this)
* `SIGCHLD`: when a process terminates or stops, this is sent to its parent; by default, this signal is ignored
  * usually inside the signal handler wait is called to fetch the child termination status
* `SIGCONT`: this signal is sent to a stopped process when it is continued; in this case, the default behaviour is to continue the process, if it was stopped
* `SIGFPE`: arithmetic exception
* `SIGHUP`: this signal is sent to the controlling process (session leader) when a disconnect is detected by the terminal interface (note that the controlling process may be in the background)
  * also this signal is sent to the foreground process group when the session leader terminates (i.e. reboot)
  * commonly used to tell daemons to re-read their configuration files (since daemons do not have controlling terminals and SIGHUP would be non-sense)
* `SIGINT`: signal generated by the terminal when we press Control-C and sent to all processes in the foreground process group
* `SIGKILL`: signal which can't be ignored, terminates a process
* `SIGPIPE`: this signal is generated when we write to a pipe but the read-end of the pipe has already been closed
* `SIGIO, SIGPOLL`: I/O related asynchronous events
* `SIGPWR`: generally sent by the kernel to hardware connected to batteries, when the charge is very low and system should shutdown
* `SIGQUIT`: this signal is generated by the terminal driver when we type the terminal quit key (Control-backslash)
  * this is sent to all processes in the foreground process group
  * by default, it terminates and generates a core file
* `SIGSEV`: memory violation
* `SIGSTOP`: this signal stops a process, it's very similar to SIGTSTP but it cannot be ignored
* `SIGSYS`: invalid system call, generally when we update some kernel API
* `SIGTERM`: default signal sent by `kill`
* `SIGTSTP`: signal sent by the terminal driver when we press Control-Z to push the foreground process group into background
* `SIGTTIN`: this signal is generated when a background process wants to read from the controlling terminal
* `SIGTTOU`: this signals that a background process is writing to the controlling terminal; this can be allowed normally
* `SIGUSR1, SIGUSR2`: user defined signals
* `SIGWINCH`: this signal is sent when the kernel detects a change of size of a terminal or pseudo-terminal

## signal function

* `void (*signal (int signo, void (*func) (int))) (int)`
* the signo argument is simply the name of the signal
* the value of func may be
  * the constant `SIG_IGN`, to ignore the signal
  * the constact `SIG_DFL`, to reset the default behaviour associated to the signal
  * the address of a function to be called when the signal occurs (signal handler or signal-catching function)
* the signature of the signal function could be made much more simpler with
  * `typedef void Sigfunc(int)`
  * `Sigfunc *signal(int signo, Sigfunc *func)`
* generally the constants are defined as
  * `#define SIG_ERR    (void (*) ()) -1`
  * `#define SIG_DFL    (void (*) ())  0`
  * `#define SIG_IGN    (void (*) ())  1`
